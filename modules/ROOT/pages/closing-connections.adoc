= Closing the connection
:page-topic-type: concept

[abstract]
Both `Cluster` and `IBucket` objects implement the IDisposable pattern and also have finalizers.

Managing the lifetime of the objects `Cluster` and `IBucket` is critical for developing robust, high-performance applications.
In a typical application, you would create a single, static `Cluster` object that would live for the duration of the application or the processâ€™s lifetime.
Create the `Cluster` object when the application starts and call it [.api]`Dispose` method when the application shuts down.
Depending upon finalization is not suggested, but it is admissible in certain applications.

== Closing the bucket

You can close a bucket and release the internal connections by using one of the following methods:

* Through finalization and garbage collection (GC)
* Calling `Dispose` explicitly or implicitly via the `using` statement
* By calling `Cluster.CloseBucket()` and passing the bucket reference

The least dependable method is to use finalization and garbage collection that relies on a certain amount of nondeterminism.
In that method, you are relying on the common language runtime (CLR) finalization mechanism, which just lets the object go out of scope.

The other methods are preferred because you deterministically control the object's lifetime.
Here is an example that uses the `Cluster.CloseBucket()` method:

[source,csharp]
----
  using (var cluster = new Cluster(config))
  {
      IBucket bucket = null;
      try
      {
          bucket = cluster.OpenBucket();
          //use the bucket here
      }
      finally
      {
          if (bucket != null)
          {
              cluster.CloseBucket(bucket);
          }
      }
  }
----

IMPORTANT: References to the [.api]`CouchbaseBucket` (or [.api]`MemcachedBucket`) are reference counted because multiple threads might be using the same object.
If multiple threads are using the bucket and each calls [.api]`Cluster.CloseBucket()` or [.api]`Dispose()`, either implicitly through the `using` statement or explicitly, the instance will not be disposed until the reference count reaches zero.
